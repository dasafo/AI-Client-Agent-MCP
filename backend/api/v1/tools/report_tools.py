from backend.mcp_instance import mcp
from backend.services.manager_service import get_manager_by_name, get_manager_by_email
from backend.services.client_service import get_all_clients, get_client_by_id
from backend.services.invoice_service import get_invoices_by_client_id, get_all_invoices
import openai
from typing import Optional
import smtplib
from email.message import EmailMessage
from backend.services.report_service import save_report, get_client_by_name, filter_invoices_by_period
import asyncpg
import matplotlib.pyplot as plt
import io
import base64
import re
from backend.core.config import SMTP_USER, SMTP_HOST, SMTP_PORT, SMTP_PASS, OPENAI_API_KEY, DATABASE_URL, REPORT_API_TOKEN
from backend.core.logging import get_logger
from backend.models.report import ReportOut
import bleach

logger = get_logger(__name__)

def build_report_prompt(invoices, client_name, period, report_type, manager_name=None, manager_email=None):
    """
    Builds a prompt for the report generation.
    """
    if period:
        periodo_texto = f"for the period {period}"
    else:
        periodo_texto = "considering all registered invoices"
    
    if client_name:
        cliente_texto = f"for client {client_name}"
    else:
        cliente_texto = "global"

    resumen = f"""
You are a professional financial analyst. Prepare a {report_type} billing report {cliente_texto} {periodo_texto}.

The report must be in professional HTML format, with clear tables and sections. Do not include suggestions for developers or meta comments; the report must be ready to be sent directly to the manager.

Structure the report in the following sections:
1. Executive summary (maximum 5 lines)
2. Billing analysis (totals, pending, collections, unpaid)
3. Detected patterns or trends
4. Recommendations for the manager

Billing data:
{chr(10).join([f"ID: {i['id']}, Amount: {i['amount']}, Status: {i['status']}, Date: {i['issued_at']}" for i in invoices])}

Be clear, professional, and concise. The report must be ready to be sent to a verified manager listed in the managers table.
"""
    if manager_name and manager_email:
        resumen += f"\n\nNote: This report will be sent to {manager_name} <{manager_email}>."
    return resumen

def generate_invoice_status_chart(invoices):
    """
    Generates a chart of invoice statuses.
    """
    # Count invoices by status
    estados = ['completed', 'pending', 'canceled']
    counts = [len([i for i in invoices if i['status'] == estado]) for estado in estados]
    # Create chart
    fig, ax = plt.subplots()
    ax.bar(estados, counts, color=['#4CAF50', '#FFC107', '#F44336'])
    ax.set_ylabel('Number of invoices')
    ax.set_title('Invoices by status')
    # Save to buffer
    buf = io.BytesIO()
    plt.tight_layout()
    plt.savefig(buf, format='png')
    plt.close(fig)
    buf.seek(0)
    return buf.read()

def clean_llm_html(html_text):
    """
    Sanitizes HTML generated by LLM using Bleach and removes markdown code blocks and stray CSS.
    - Removes markdown code blocks (```html ... ``` and ``` ... ```)
    - Removes any line that looks like stray CSS (e.g., h1 { ... }, table { ... })
    - Then sanitizes with Bleach
    """
    # Remove markdown code blocks
    cleaned = re.sub(r'```html\s*([\s\S]*?)```', r'\1', html_text, flags=re.IGNORECASE)
    cleaned = re.sub(r'```[\s\S]*?```', '', cleaned)
    # Remove any line that looks like stray CSS (e.g., h1 { ... }, table { ... })
    cleaned = re.sub(r'^[^<\n]*\{[^}]+\}\s*$', '', cleaned, flags=re.MULTILINE)
    # Now sanitize with Bleach
    allowed_tags = [
        'b', 'i', 'u', 'em', 'strong', 'p', 'ul', 'ol', 'li', 'br', 'span', 'div',
        'table', 'thead', 'tbody', 'tr', 'th', 'td', 'a', 'img',
        'h1', 'h2', 'h3', 'h4', 'h5', 'h6'
    ]
    allowed_attributes = {
        'a': ['href', 'title', 'target', 'rel'],
        'img': ['src', 'alt', 'title', 'width', 'height'],
    }
    cleaned = bleach.clean(
        cleaned,
        tags=allowed_tags,
        attributes=allowed_attributes,
        protocols=['http', 'https', 'mailto', 'data'],
        strip=True,
        strip_comments=True
    )
    return cleaned.strip()

async def send_email_with_report(to_email, report_text, subject="Report", invoices=None):
    """
    Sends an email with the generated report.
    """
    msg = EmailMessage()
    msg['Subject'] = subject
    msg['From'] = SMTP_USER
    msg['To'] = to_email
    msg.set_content("This email contains an HTML report. If you do not see it correctly, use a compatible client.")

    # Attach chart as base64 if there are invoices
    html_report = clean_llm_html(report_text)
    if invoices:
        img_bytes = generate_invoice_status_chart(invoices)
        img_b64 = base64.b64encode(img_bytes).decode('utf-8')
        img_tag = f'<img src="data:image/png;base64,{img_b64}" alt="Invoices by status chart" style="max-width:400px;"><br>'
        if '<img' not in html_report:
            html_report = img_tag + html_report
    msg.add_alternative(html_report, subtype='html')

    smtp_host = SMTP_HOST
    smtp_port = SMTP_PORT
    smtp_user = SMTP_USER
    smtp_pass = SMTP_PASS

    try:
        with smtplib.SMTP_SSL(smtp_host, smtp_port) as smtp:
            smtp.login(smtp_user, smtp_pass)
            smtp.send_message(msg)
        return True
    except Exception as e:
        logger.error(f"Error sending email: {e}")
        raise

async def obtener_manager_autorizado(manager_name, manager_email):
    """
    Retrieves a manager by name or email.
    """
    if manager_name:
        return await get_manager_by_name(manager_name)
    elif manager_email:
        return await get_manager_by_email(manager_email)
    return None

async def obtener_invoices_cliente_periodo(client_name, period):
    """
    Retrieves invoices for a client by name and period.
    """
    if client_name:
        client_obj = await get_client_by_name(client_name)
        if not client_obj:
            return None, None
        invoices = await get_invoices_by_client_id(client_obj['id'])
    else:
        client_obj = None
        invoices = await get_all_invoices()
    if period:
        invoices = filter_invoices_by_period(invoices, period)
    return client_obj, invoices

def generar_texto_informe_llm(invoices, client_name, period, report_type, manager):
    """
    Generates a report text using LLM.
    """
    prompt = build_report_prompt(invoices, client_name, period, report_type, manager['name'], manager['email'])
    from openai import OpenAI
    openai_client = OpenAI(api_key=OPENAI_API_KEY)
    response = openai_client.chat.completions.create(
        model="gpt-4o-mini-2024-07-18",
        messages=[
            {"role": "system", "content": (
                "You are an expert assistant in business billing analysis with experience in accounting, finance, and business report writing. "
                "Your main task is to generate clear, concise, and visually professional reports for company managers, using billing data obtained from a database connected to an MCP system. "
                "Always validate that the recipient is authorized and adapt the report to the requested type (general, executive, delinquency, etc.)."
            )},
            {"role": "user", "content": prompt}
        ]
    )
    return response.choices[0].message.content

async def guardar_informe_db(client_obj, client_name, period, manager, report_type, report_text):
    """
    Saves the report to the database.
    """
    client_id = client_obj['id'] if client_obj else None
    db_url = DATABASE_URL
    conn = await asyncpg.connect(dsn=db_url)
    save_result = await save_report(
        conn,
        client_id,
        client_name if client_name else None,
        period if period else None,
        manager['email'],
        manager['name'],
        report_type,
        report_text
    )
    await conn.close()
    return save_result

def build_email_subject(client_name, report_type, period=None):
    """
    Builds a descriptive subject for the report email.
    """
    subject = f"Billing Report for {client_name} ({report_type})"
    if period:
        subject += f" - Period: {period}"
    return subject

@mcp.tool(
    name="generate_report",
    description="Generates a professional business report and sends it to the authorized manager by email. Requires a valid api_token."
)
async def generate_report(
    client_name: str,
    period: str,
    manager_name: str,
    manager_email: str,
    report_type: str,
    api_token: str
):
    """
    Generates a professional business report and sends it to the authorized manager by email.
    """
    if api_token != REPORT_API_TOKEN:
        logger.warning("Attempted access with invalid api_token in generate_report")
        return {"success": False, "error": "Invalid or missing API token. Access denied."}
    try:
        manager = await obtener_manager_autorizado(manager_name, manager_email)
        if not manager:
            return {"success": False, "error": "Recipient not authorized to receive reports."}
        client_obj, invoices = await obtener_invoices_cliente_periodo(client_name, period)
        if client_name and not client_obj:
            return {"success": False, "error": "Client not found."}
        if not invoices:
            return {"success": False, "message": f"No invoices for client '{client_name}' in period '{period}'."}
        report_text = generar_texto_informe_llm(invoices, client_name, period, report_type, manager)
        subject = build_email_subject(client_name, report_type, period)
        await send_email_with_report(manager['email'], report_text, subject=subject, invoices=invoices)
        save_result = await guardar_informe_db(client_obj, client_name, period, manager, report_type, report_text)
        if not save_result.get("success", True):
            return {"success": False, "error": save_result.get("error", "Error saving the report to the database.")}
        return {"success": True, "message": f"Report sent to {manager['name']} <{manager['email']}>"}
    except Exception as e:
        logger.error(f"Error in generate_report: {e}")
        return {"success": False, "error": str(e)}

@mcp.tool(
    name="list_reports",
    description="List all generated reports in the database."
)
async def list_reports() -> dict:
    """
    Lists all generated reports in the database.
    """
    try:
        db_url = DATABASE_URL
        conn = await asyncpg.connect(dsn=db_url)
        rows = await conn.fetch("SELECT * FROM reports ORDER BY created_at DESC")
        await conn.close()
        reports = [ReportOut(**dict(row)) for row in rows]
        return {"success": True, "reports": [r.model_dump() for r in reports]}
    except Exception as e:
        logger.error(f"Error listing reports: {e}")
        return {"success": False, "error": str(e)}
